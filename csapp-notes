Intel IA32
x86-64

A program written in a high-level language can be compiled and executed on a number of different machines, whereas assembly code is highly machine specific.

3.2 PROGRAM ENCODINGS

unix> gcc -O1 -S code.c

* -S causes gcc to run the compiler, generating an assembly file code.s, and go no further.

unix> gcc -O1 -o p p1.c p2.c

* gcc indicated GCC compiler which is the default compiler of Linux and can be invoked simply as cc
* -01 instructs the compiler to apply level-one optimizations

unix> objdump -d prog

* 

How does the command above being processed?
1. C preprocessor expands the source code to include any files specified with #include commands and to expand any macros, specified with #define declarations.
2. The compiler generates assembly code versions of the two source files having names p1.s and p2.s.
3. The assembler converts the assembly code into binary object-code files p1.o and p2.o.
  > Object code is one form of machine code—it contains binary representations of all of the instructions, but the addresses of global values are not yet filled in.
4. The linker merges these two object-code files along with code implementing library functions (e.g., printf) and generates the final executable code file p.


3.2.1 MACHINE-LEVEL-CODE

Instruction set architecture or ISA defines the processor state, the format of the instructions, and the effect each of the instructions will have on the state. 

The following are parts of the processor state that are normally hidden from the programmer:
1. Program counter (commonly referred to as the PC and called %eip in IA32) indicates the address in memory of the next instruction to be executed.
2. Integer register file contains 8 named locations storing 32-bit values. These integers can hold addresses (corresponding to C pointers) or integer data.
3. The condition code registers hold status information about the most recently executed arithmetic or logical instruction.
4. A set of floating-point registers store floating-point data.

>How do I find the byte representation of a program?

Disassemblers is used to inspect the contents of machine-code files by generating a format similar ot assembly code from the machine code.

unix> objdump -d code.o

Several features about machine code and its disassembled representation are worth noting:

3.2.3 NOTES ON FORMATTING


// C Program
1 int simple(int *xp, int y)
2 {
3 int t = *xp + y;
4 *xp = t;
5 return t;
6 }

// Assembly Program
.file "simple.c"
.text
.globl simple
.type simple, @function
simple:
pushl %ebp
movl %esp, %ebp
movl 8(%ebp), %edx
movl 12(%ebp), %eax
addl (%edx), %eax
movl %eax, (%edx)
popl %ebp
ret
.size simple, .-simple
.ident "GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2"
.section .note.GNU-stack,"",@progbits

 All of the lines beginning with ‘.’ are directives to guide the assembler andlinker.

3.3 DATA FORMATS
word = 16-bit
double word = 32-bit
quad word = 64-bit

Go to page 202. Then, copy Figure 3.1

All eight registers can be accessed as either 16 bits (word) or 32 bits (double word). 
The 2 loworder bytes of the first four registers can be accessed independently.

For the most part, the first six registers can be considered general-purpose registers
with no restrictions placed on their use.We said “for the most part,” because
some instructions use fixed registers as sources and/or destinations. In addition,
within procedures there are different conventions for saving and restoring the
first three registers (%eax, %ecx, and %edx) than for the next three (%ebx, %edi,
and %esi)

When a byte instruction updates one of these single-byte “register elements,” the remaining 
3 bytes of the register do not change. 

The final two registers (%ebp and %esp) contain pointers to important places in the program stack. 
They should only be altered according to the set of standard conventions for stack management.



3.4 ACCESSING INFORMATION

3.4.1 OPERAND SPECIFIERS
An instruction can have one or more operands, specifiyung the source values to reference in performing an operation and the destination into which to place the result.

Go to page 204. Then, copy Figure 3.1

The different operand possibilities can be classified into 3 types:
1. Immediate is for constant values
2. Register denotes the contents of one of the registers
3. Memory reference used to access some memory location according to a computeed address, often called effective address

The most general form is shown at the bottom
of the table with syntax Imm(Eb,Ei,s). Such a reference has four components:
an immediate offset Imm, a base register Eb, an index register Ei, and a scale
factor s, where s must be 1, 2, 4, or 8. The effective address is then computed
as Imm + R[Eb] + R[Ei] . s. This general form is often seen when referencing elements of arrays.

3.4.2 DATA MOVEMENT INSTRUCTIONS

The instructions in the mov class copy their source values to their destinations. The source operand designates a value that is immediate, stored in a register, or
stored in memory. The destination operand designates a location that is either a register or a memory address  IA32 imposes the restriction that a move instruction
cannot have both operands refer to memory locations.  Copying a value from one memory location to another requires two instructions—the first to load the source value into a register, and the second to write this register value to the destination.

Both the movs and the movz instruction classes serve to copy a smaller amount
of source data to a larger data location, filling in the upper bits by either sign
expansion (movs) or by zero expansion (movz).

Go to page 206. Then, copy Figure 3.4

With IA32, the program stack is stored in some region of memory. The pushl instruction provides the ability to push data onto the stack, while
the popl instruction pops it. 

IA32 stacks grow toward lower addresses, so pushing involves decrementing the stack pointer (register %esp) and
storing to memory, while popping involves reading from memory and incrementing the
stack pointer.


Go to page 208 for illustration of stack pointer
Pushing a double-word value onto the stack involves first decrementing the
stack pointer by 4 and then writing the value at the new top of stack address.

> subl $4,%esp Decrement stack pointer
> movl %ebp,(%esp) Store %ebp on stack

Popping a double word involves reading from the top of stack location and
then incrementing the stack pointer by 4.

>movl (%esp),%eax Read %eax from stack
>addl $4,%esp Increment stack pointer


Two features about this assembly code are worth noting. First, we see that what
we call “pointers” in C are simply addresses. Dereferencing a pointer involves
copying that pointer into a register, and then using this register in a memory
reference. Second, local variables such as x are often kept in registers rather than
stored in memory locations. Register access is much faster than memory access


3.5 ARITHMETC AND LOGICAL OPERATIONS

The operations are divided into four groups: load effective address, unary, binary,
and shifts.

Go to page 213 for the table of arithmetic operations

3.5.1 LOAD EFFECTIVE ADDRESS
Among all instruction sets, only leal has no size variants.

> leal S, D 		D ← &S

Its first operand appears to be a memory reference, but instead of reading from the designated location, the instruction copies
the effective address to the destination.

3.5.2.1 Binary Operations

inc D D ← D + 1 Increment
dec D D ← D - 1 Decrement
neg D D ← -D Negate
not D D ← ~D Complement


Operations in the second group are unary operations, with the single operand
serving as both source and destination. This operand can be either a register or
a memory location. 

3.5.2.2 Binary Operations

add S, D D ← D + S Add
sub S, D D ← D - S Subtract
imul S, D D ← D * S Multiply
xor S, D D ← D ^ S Exclusive-or
or S, D D ← D | S Or
and S, D D ← D & S And

The third group consists of binary operations, where the second operand
is used as both a source and a destination. 

3.5.3 SHIFT OPERATION

sal k, D D ← D << k Left shift
shl k, D D ← D << k Left shift (same as sal)
sar k, D D ← D >>A k Arithmetic right shift
shr k, D D ← D >>L k Logical right shift

 The shift amount is encoded as a single byte, since only shift amounts
between 0 and 31 are possible (only the low-order 5 bits of the shift amount are
considered). It is given either as an immediate or in the singlebyte register element %cl.

3.5.5 SPECAL ARITHMETIC OPERATIONS

Go to page 21 for the Special Arithmetic Operations


3.6 CONTROL

LAST PAGe 220

